(function () {
    var array2Object, balancePadding, clearStage, copyObj, createText, createText2, getBalancingCoefficient, getModels, getPadding, getSignHeight, getSignWidth, getSizesTexts, getSpace, getTextHeight, getTextWidth, modelTemplate, models, onChange, reRender, roundRect, saveModels, settings, signs, simpleCreateText, simpleRect;
    $(function () {
        return $("select").selectpicker()
    });
    signs = angular.module("Signs", ["file-model"]);
    settings = {
        PIXEL_SIZE: 8,
        canvasHeight: 500,
        canvasWidth: 555,
        shapes: ["rectangle", "round", "rounded rectangle"],
        holes: ["Top left corner", "Top right corner", "Middle left", "Middle right", "Bottom left corner", "Bottom right corner"],
        fonts: ["Times New Roman", "Arial"],
        materials: ["Steel", "Mystic material"],
        alignment: ["Left", "Center", "Right"],
        themes: [{name: "black / white", bgColor: "white", textColor: "black"}, {
            name: "black / yellow",
            bgColor: "yellow",
            textColor: "black"
        }, {name: "black / red", bgColor: "red", textColor: "black"}, {
            name: "white / red",
            bgColor: "red",
            textColor: "white"
        }, {name: "red / white", bgColor: "white", textColor: "red"}],
        fonts: ["Arial", "Times New Roman", "Arial Narrow", "Calibri"],
        maxLinesOfText: 4,
        margin: 15,
        radius: 5,
        borderWidth: 1.5
    };
    copyObj = function (obj) {
        return JSON.parse(JSON.stringify(obj))
    };
    array2Object = function (array) {
        var i, object, _i, _len;
        object = {};
        for (_i = 0, _len = array.length; _i < _len; _i++) {
            i = array[_i];
            object[i] = false
        }
        object[0] = true;
        return object
    };
    modelTemplate = {
        name: "New Sign",
        shape: settings.shapes[0],
        holes: array2Object(settings.holes),
        fonts: settings.fonts[0],
        material: settings.materials[0],
        theme: {name: "black / yellow", bgColor: "yellow", textColor: "black"},
        order: 0,
        texts: [{text: "Your text here", size: 5, align: "Center"}],
        size: {width: 30, height: 10, autoHeight: true, autoWidth: true},
        font: "Arial"
    };
    models = [];
    getModels = function () {
        models.push(copyObj(modelTemplate));
        return models
    };
    saveModels = function (models) {
        return models
    };
    roundRect = function (x, y, width, height, radius, borderWidth, fillColor, strokeColor) {
        return new Konva.Shape({
            drawFunc: function (ctx) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                return ctx.fillStrokeShape(this)
            },
            fill: fillColor || "black",
            stroke: strokeColor || "black",
            strokeWidth: borderWidth,
            shadowOffsetX: 3,
            shadowOffsetY: 2,
            shadowBlur: 15
        })
    };
    simpleRect = function (x, y, width, height) {
        return new Konva.Rect({x: x, y: y, width: width, height: height, stroke: "black", strokeWidth: 1})
    };
    createText = function (align, str, x, y, width, font, size, color) {
        var textObj;
        return textObj = new Konva.Text({
            x: x,
            y: y,
            text: str,
            fontSize: size * settings.PIXEL_SIZE,
            fontFamily: font,
            fill: color,
            width: width,
            align: align.toLowerCase()
        })
    };
    createText2 = function (align, str, x, y, font, size, color) {
        var textObj;
        return textObj = new Konva.Text({
            x: x,
            y: y,
            text: str,
            fontSize: size * settings.PIXEL_SIZE,
            fontFamily: font,
            fill: color,
            align: align.toLowerCase()
        })
    };
    simpleCreateText = function (layer, model, obj) {
        var textObj;
        textObj = createText(obj.align, obj.text, 0, 0, 0, model.font, obj.size, model.theme.textColor);
        console.log(textObj.getTextHeight());
        layer.add(textObj);
        return textObj
    };
    getSpace = function (width, squareWidth) {
        return width / 2 - squareWidth / 2
    };
    getSizesTexts = function (model) {
        var sizes, text, textObj, _i, _len, _ref;
        sizes = [];
        _ref = model.texts;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            text = _ref[_i];
            textObj = createText2(text.align, text.text, 0, 0, model.font, text.size, model.theme.textColor);
            sizes.push({width: textObj.getTextWidth(), height: textObj.getTextHeight()})
        }
        return sizes
    };
    getTextWidth = function (sizes) {
        var maxLen, size, _i, _len;
        maxLen = 0;
        for (_i = 0, _len = sizes.length; _i < _len; _i++) {
            size = sizes[_i];
            if (size.width > maxLen) {
                maxLen = size.width
            }
        }
        return maxLen
    };
    getTextHeight = function (sizes, padding) {
        var size, sum, _i, _len;
        sum = 0;
        for (_i = 0, _len = sizes.length; _i < _len; _i++) {
            size = sizes[_i];
            sum += size.height
        }
        return sum + padding * (sizes.length - 1)
    };
    getSignWidth = function (size, padding) {
        return size + padding
    };
    getSignHeight = function (size, padding) {
        return size + padding
    };
    getPadding = function (model) {
        var h, is_left, is_right;
        h = model.holes;
        is_left = h["Middle left"] || h["Top left corner"] || h["Bottom left corner"];
        is_right = h["Middle right"] || h["Top right corner"] || h["Bottom right corner"];
        return {
            top: 15,
            bottom: 15,
            left: is_left != null ? is_left : {45: 15},
            right: is_right != null ? is_right : {45: 15},
            width: function () {
                return this.left + this.right
            },
            height: function () {
                return this.top + this.bottom
            },
            text: 0
        }
    };
    balancePadding = function (padding, text_width) {
        text_width /= 100;
        padding.left += text_width;
        padding.right += text_width;
        return padding
    };
    getBalancingCoefficient = function (width, height, canvasWidth, canvasHeight) {
        var fatalHeight, fatalWidth, new_k, oneWeUse;
        fatalWidth = width / canvasWidth;
        fatalHeight = height / canvasHeight;
        oneWeUse = fatalHeight > fatalWidth ? fatalHeight : fatalWidth;
        if (oneWeUse > .8) {
            new_k = oneWeUse;
            while (new_k > .8) {
                new_k = new_k *= .9
            }
            return new_k / oneWeUse
        } else {
            return 1
        }
    };
    clearStage = function (stage) {
        var layer, layers, _i, _len;
        stage.clear();
        layers = stage.getLayers().toArray();
        for (_i = 0, _len = layers.length; _i < _len; _i++) {
            layer = layers[_i];
            layer.destroy()
        }
    };
    onChange = function (stage, model) {
        var k, padding, signBegin, signSize, size, sizes, textBegin, textSize;
        padding = getPadding(model);
        sizes = getSizesTexts(model);
        textSize = {};
        textSize.width = getTextWidth(sizes);
        textSize.height = getTextHeight(sizes, padding.text);
        padding = balancePadding(padding, textSize.width);
        signSize = {};
        signSize.width = getSignWidth(textSize.width, padding.width());
        signSize.height = getSignHeight(textSize.height, padding.height());
        k = getBalancingCoefficient(signSize.width, signSize.height, settings.canvasWidth, settings.canvasHeight);
        signBegin = {};
        signBegin.x = getSpace(settings.canvasWidth, k * signSize.width);
        signBegin.y = getSpace(settings.canvasHeight, k * signSize.height);
        textBegin = {};
        textBegin.x = signBegin.x + k * padding.left;
        textBegin.y = signBegin.y + k * padding.top;
        size = {
            k: k,
            sign: {x: signBegin.x, y: signBegin.y, width: k * signSize.width, height: k * signSize.height},
            text: {x: textBegin.x, y: textBegin.y, width: k * textSize.width, height: k * textSize.height},
            padding: padding
        };
        console.log("padding.x: " + size.padding.width() + "; padding.y: " + size.padding.height());
        console.log("sign x: " + size.sign.x + ";	y: " + size.sign.y);
        console.log("text x: " + size.text.x + ";	y: " + size.sign.y);
        console.log("width: " + size.sign.width + "; height: " + size.sign.height);
        return reRender(stage, model, size)
    };
    reRender = function (stage, model, size) {
        var id, rect, rectKonva, shapeLayer, text, textKonva, textLayer, _i, _len, _ref;
        clearStage(stage);
        shapeLayer = new Konva.Layer;
        textLayer = new Konva.Layer;
        stage.add(shapeLayer);
        stage.add(textLayer);
        _ref = model.texts;
        for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
            text = _ref[id];
            textKonva = createText(text.align, text.text, size.text.x, size.text.y, size.text.width + 1, model.font, size.k * text.size, model.theme.textColor);
            rect = simpleRect(size.text.x, size.text.y, size.text.width + 1, textKonva.getHeight());
            size.text.y += textKonva.getHeight() + size.padding.text;
            textLayer.add(textKonva);
            textLayer.add(rect)
        }
        rectKonva = roundRect(size.sign.x, size.sign.y, size.sign.width, size.sign.height, settings.radius, settings.borderWidth, model.theme.bgColor, model.theme.textColor);
        shapeLayer.add(rectKonva);
        shapeLayer.draw();
        return textLayer.draw()
    };
    signs.controller("shapesController", function ($scope) {
        return $scope.shapes = settings.shapes
    });
    signs.controller("holesController", function ($scope) {
        return $scope.holes = settings.holes
    });
    signs.controller("fontsController", function ($scope) {
        return $scope.fonts = settings.fonts
    });
    signs.controller("materialsController", function ($scope) {
        return $scope.materials = settings.materials
    });
    signs.controller("colorController", function ($scope) {
        return $scope.color = settings.color
    });
    signs.controller("sizeController", function ($scope) {
    });
    signs.controller("fontController", function ($scope) {
        return $scope.fonts = settings.fonts
    });
    signs.controller("themesController", function ($scope) {
        return $scope.themes = settings.themes
    });
    signs.controller("textController", function ($scope) {
        $scope.alignment = settings.alignment;
        $scope.isDisabled = function () {
            return $scope.model.texts.length >= settings.maxLinesOfText
        };
        $scope.addText = function () {
            if (!$scope.isDisabled()) {
                return $scope.model.texts.push(copyObj(modelTemplate.texts[0]))
            }
        };
        $scope.removeText = function ($index) {
            return $scope.model.texts.splice($index, 1)
        };
        $scope.setAlign = function (align, index) {
            return $scope.model.texts[index].align = align
        };
        $scope.increaseSize = function (index, size) {
            if (size == null) {
                size = 1
            }
            return $scope.model.texts[index].size += size
        };
        return $scope.decreaseSize = function (index, size) {
            if (size == null) {
                size = 1
            }
            return $scope.increaseSize(index, -size)
        }
    });
    signs.controller("modelsController", function ($scope) {
        $scope.init = function () {
            return $scope.stage = new Konva.Stage({
                container: "preview",
                width: settings.canvasWidth,
                height: settings.canvasHeight
            })
        };
        $scope.file = {};
        $scope.$watch("file", function (newVal) {
            var reader;
            reader = new FileReader;
            reader.onload = function (event) {
                var contents, sheet, sheets;
                contents = event.target.result;
                sheets = XLS.read(contents, {type: "binary"});
                sheet = sheets.Sheets[sheets.SheetNames[0]];
                return console.log(sheet)
            };
            return reader.onerror = function (event) {
                return console.error("Problems reading file, code:  " + event.target.error.code)
            }
        });
        $scope.triggerImport = function () {
            return $("#file").trigger("click")
        };
        $scope.onChange = onChange;
        $scope.models = getModels();
        $scope.current = 0;
        $scope["new"] = function () {
            return $scope.models.push(copyObj(modelTemplate))
        };
        $scope.model = $scope.models[$scope.current];
        $scope.updateCurrentModel = function (index) {
            $scope.current = index;
            return $scope.model = $scope.models[$scope.current]
        };
        $scope.$watch("model", function () {
            return $scope.onChange($scope.stage, $scope.model)
        }, true);
        $scope.calcPrice = function (model) {
            if (model == null) {
                model = $scope.model
            }
            return model.order * 20
        };
        return $scope.summary = function (models) {
            var model, summary, _i, _len;
            if (models == null) {
                models = $scope.models
            }
            summary = {};
            summary.price = 0;
            summary.order = 0;
            for (_i = 0, _len = models.length; _i < _len; _i++) {
                model = models[_i];
                summary.price += $scope.calcPrice(model);
                summary.order += model.order
            }
            return summary
        }
    })
}).call(this);