// Generated by CoffeeScript 1.9.0
(function() {
  var array2Object, clearStage, copyObj, createText, createText2, getBalancingCoefficient, getModels, getSizesTexts, getSpace, getTextHeight, getTextWidth, initDraw, modelTemplate, models, reRender, reRender_, roundRect, saveModels, settings, signs, simpleCreateText;

  $(function() {
    return $('select').selectpicker();
  });

  signs = angular.module('Signs', ['file-model']);

  settings = {
    PIXEL_SIZE: 3.77,
    canvasHeight: 500,
    canvasWidth: 555,
    shapes: ["rectangle", "round", "rounded rectangle"],
    holes: ["Top left corner", "Top right corner", "Middle left", "Middle right", "Bottom left corner", "Bottom right corner"],
    fonts: ["Times New Roman", "Arial"],
    materials: ["Steel", "Mystic material"],
    alignment: ["Left", "Center", "Right"],
    themes: [
      {
        name: "black / yellow",
        bgColor: "yellow",
        textColor: "black"
      }, {
        name: "black / red",
        bgColor: "red",
        textColor: "black"
      }, {
        name: "white / red",
        bgColor: "red",
        textColor: "white"
      }, {
        name: "red / white",
        bgColor: "white",
        textColor: "red"
      }
    ],
    fonts: ["Arial", "Times New Roman", "Arial Narrow", "Calibri"],
    maxLinesOfText: 4,
    margin: 15,
    radius: 5,
    borderWidth: 1.5
  };

  copyObj = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };

  array2Object = function(array) {
    var i, object, _i, _len;
    object = {};
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      i = array[_i];
      object[i] = false;
    }
    object[0] = true;
    return object;
  };

  modelTemplate = {
    name: "New Sign",
    shape: settings.shapes[0],
    holes: array2Object(settings.holes),
    fonts: settings.fonts[0],
    material: settings.materials[0],
    theme: {
      name: "black / yellow",
      bgColor: "yellow",
      textColor: "black"
    },
    order: 0,
    texts: [
      {
        text: "Your text here",
        size: 5,
        align: "Center"
      }
    ],
    size: {
      width: 30,
      height: 10,
      autoHeight: true,
      autoWidth: true
    },
    font: "Arial"
  };

  models = [];

  getModels = function() {
    models.push(copyObj(modelTemplate));
    return models;
  };

  saveModels = function(models) {
    return models;
  };

  getSpace = function(width, squareWidth) {
    return width / 2 - squareWidth / 2;
  };

  roundRect = function(x, y, width, height, radius, borderWidth, fillColor, strokeColor) {
    return new Konva.Shape({
      drawFunc: function(ctx) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        return ctx.fillStrokeShape(this);
      },
      fill: fillColor || 'black',
      stroke: strokeColor || 'black',
      strokeWidth: borderWidth,
      shadowOffsetX: 3,
      shadowOffsetY: 2,
      shadowBlur: 15
    });
  };

  createText = function(align, str, x, y, width, font, size, color) {
    var textObj;
    return textObj = new Konva.Text({
      x: x,
      y: y,
      text: str,
      fontSize: size * settings.PIXEL_SIZE,
      fontFamily: font,
      fill: color,
      width: width,
      align: align.toLowerCase()
    });
  };

  createText2 = function(align, str, x, y, font, size, color) {
    var textObj;
    return textObj = new Konva.Text({
      x: x,
      y: y,
      text: str,
      fontSize: size * settings.PIXEL_SIZE,
      fontFamily: font,
      fill: color,
      align: align.toLowerCase()
    });
  };

  simpleCreateText = function(layer, model, obj) {
    var textObj;
    textObj = createText(obj.align, obj.text, 0, 0, 0, model.font, obj.size, model.theme.textColor);
    console.log(textObj.getTextHeight());
    layer.add(textObj);
    return textObj;
  };

  getSizesTexts = function(model) {
    var sizes, text, textObj, _i, _len, _ref;
    sizes = [];
    _ref = model.texts;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      text = _ref[_i];
      textObj = createText2(text.align, text.text, 0, 0, model.font, text.size, model.theme.textColor);
      sizes.push({
        width: textObj.getTextWidth(),
        height: textObj.getTextHeight()
      });
    }
    return sizes;
  };

  getTextWidth = function(sizes) {
    var maxLen, size, _i, _len;
    maxLen = 0;
    for (_i = 0, _len = sizes.length; _i < _len; _i++) {
      size = sizes[_i];
      if (size.width > maxLen) {
        maxLen = size.width;
      }
    }
    return maxLen;
  };

  getTextHeight = function(sizes, padding) {
    var size, sum, _i, _len;
    sum = 0;
    for (_i = 0, _len = sizes.length; _i < _len; _i++) {
      size = sizes[_i];
      sum += size.height;
    }
    return sum + padding * (sizes.length - 1);
  };

  getBalancingCoefficient = function(width, height, canvasWidth, canvasHeight) {
    var fatalHeight, fatalWidth, new_k, oneWeUse;
    fatalWidth = width / canvasWidth;
    fatalHeight = height / canvasHeight;
    oneWeUse = fatalHeight > fatalWidth ? fatalHeight : fatalWidth;
    if (oneWeUse > 0.8) {
      new_k = oneWeUse;
      while (new_k > 0.8) {
        new_k = new_k *= 0.9;
      }
      return new_k / oneWeUse;
    } else {
      return 1;
    }
  };

  clearStage = function(stage) {
    var layer, layers, _i, _len;
    stage.clear();
    layers = stage.getLayers().toArray();
    for (_i = 0, _len = layers.length; _i < _len; _i++) {
      layer = layers[_i];
      layer.destroy();
    }
  };

  reRender = function(stage, model) {
    var id, k, padding, rectKonva, shapeLayer, signBeginX, signBeginY, signHeight, signWidth, sizes, text, textBeginX, textBeginY, textHeight, textKonva, textLayer, textWidth, top, _i, _len, _ref;
    clearStage(stage);
    shapeLayer = new Konva.Layer();
    textLayer = new Konva.Layer();
    stage.add(shapeLayer);
    stage.add(textLayer);
    top = 0;
    padding = 15;
    sizes = getSizesTexts(model);
    textWidth = getTextWidth(sizes);
    textHeight = getTextHeight(sizes, padding);
    signWidth = textWidth + 2 * padding;
    signHeight = textHeight + 2 * padding;
    console.log("width: " + signWidth + "; height: " + signHeight);
    k = getBalancingCoefficient(signWidth, signHeight, settings.canvasWidth, settings.canvasHeight);
    signBeginX = getSpace(settings.canvasWidth, k * signWidth);
    signBeginY = getSpace(settings.canvasHeight, k * signHeight);
    textBeginX = getSpace(settings.canvasWidth, k * textWidth);
    textBeginY = getSpace(settings.canvasHeight, k * textHeight);
    _ref = model.texts;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      text = _ref[id];
      textKonva = createText(text.align, text.text, textBeginX, textBeginY, k * textWidth + 1, model.font, k * text.size, model.theme.textColor);
      textLayer.add(textKonva);
      textBeginY += textKonva.getHeight() + k * padding;
    }
    rectKonva = roundRect(signBeginX, signBeginY, k * signWidth, k * signHeight, settings.radius, settings.borderWidth, model.theme.bgColor, model.theme.textColor);
    shapeLayer.add(rectKonva);
    shapeLayer.draw();
    return textLayer.draw();
  };

  reRender_ = function(stage, model) {
    var balancedSignHeight, balancedSignWidth, height, index, k, rectStartHeight, rectStartWidth, rectangle, shapeLayer, signHeight, signWidth, text, textLayer, textSizes, top, width, _i, _len, _ref;
    stage.clear();
    width = stage.width();
    height = stage.height();
    if (model.shape === "rectangle") {
      shapeLayer = new Konva.Layer();
      stage.add(shapeLayer);
      textLayer = new Konva.Layer();
      textSizes = [];
      top = 15 + rectStartHeight;
      _ref = model.texts;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        text = _ref[index];
        text = renderText(text.align, text.text, rectStartWidth, rectStartWidth, top, model.font, text.size, model.theme.textColor);
        textSizes.push(text.size());
      }
      getTextWidth = function(sizes) {
        var i, max, _j, _len1;
        max = 0;
        for (_j = 0, _len1 = textSizes.length; _j < _len1; _j++) {
          i = textSizes[_j];
          max = i.width > max ? i.width : max;
        }
        return max;
      };
      getTextHeight = function(sizes) {
        var i, summ, _j, _len1;
        summ = 0;
        for (_j = 0, _len1 = textSizes.length; _j < _len1; _j++) {
          i = textSizes[_j];
          summ += i.height;
        }
        return summ;
      };
      signWidth = getTextWidth(textSizes);
      signHeight = getTextHeight(textSizes);
      getBalancingCoefficient = function(width, height, canvasWidth, canvasHeight) {
        var fatalHeight, fatalWidth, oneWeUse;
        fatalWidth = width / canvasWidth;
        fatalHeight = height / canvasHeight;
        oneWeUse = fatalHeight > fatalWidth ? fatalHeight : fatalWidth;
        if (oneWeUse > 0.8) {
          return 0.8 / oneWeUse;
        } else {
          return 1;
        }
      };
      k = getBalancingCoefficient(signWidth, signHeight, width, height);
      balancedSignHeight = signHeight * k;
      balancedSignWidth = signWidth * k;
      rectStartWidth = getSpace(width, signWidth);
      rectStartHeight = getSpace(height, signHeight);
      rectangle = roundRect(rectStartWidth, rectStartHeight, balancedSignWidth, balancedSignHeight, settings.radius, settings.borderWidth, model.theme.bgColor, model.theme.textColor);
      shapeLayer.add(rectangle);
      return stage.add(shapeLayer);
    }
  };

  initDraw = function(layer, model) {
    var def_model, textObj;
    model.shapeObj = roundRect(0, 0, 10, 10, settings.radius, settings.borderWidth, model.theme.bgColor, model.theme.textColor);
    layer.add(model.shapeObj);
    def_model = model.texts[0];
    textObj = createText(def_model.align, def_model.text, 0, 0, 0, model.font, def_model.size, model.theme.textColor);
    def_model.textObj = textObj;
    layer.add(textObj);
    return reRender(layer, model);
  };

  signs.controller('shapesController', function($scope) {
    return $scope.shapes = settings.shapes;
  });

  signs.controller('holesController', function($scope) {
    return $scope.holes = settings.holes;
  });

  signs.controller('fontsController', function($scope) {
    return $scope.fonts = settings.fonts;
  });

  signs.controller('materialsController', function($scope) {
    return $scope.materials = settings.materials;
  });

  signs.controller('colorController', function($scope) {
    return $scope.color = settings.color;
  });

  signs.controller('sizeController', function($scope) {});

  signs.controller('fontController', function($scope) {
    return $scope.fonts = settings.fonts;
  });

  signs.controller('themesController', function($scope) {
    return $scope.themes = settings.themes;
  });

  signs.controller('textController', function($scope) {
    $scope.alignment = settings.alignment;
    $scope.isDisabled = function() {
      return $scope.model.texts.length >= settings.maxLinesOfText;
    };
    $scope.addText = function() {
      if (!$scope.isDisabled()) {
        return $scope.model.texts.push(copyObj(modelTemplate.texts[0]));
      }
    };
    $scope.removeText = function($index) {
      return $scope.model.texts.splice($index, 1);
    };
    $scope.setAlign = function(align, index) {
      return $scope.model.texts[index].align = align;
    };
    $scope.increaseSize = function(index, size) {
      if (size == null) {
        size = 1;
      }
      return $scope.model.texts[index].size += size;
    };
    return $scope.decreaseSize = function(index, size) {
      if (size == null) {
        size = 1;
      }
      return $scope.increaseSize(index, -size);
    };
  });

  signs.controller('modelsController', function($scope) {
    $scope.init = function() {
      return $scope.stage = new Konva.Stage({
        container: 'preview',
        width: settings.canvasWidth,
        height: settings.canvasHeight
      });
    };
    $scope.file = {};
    $scope.$watch('file', function(newVal) {
      var reader;
      reader = new FileReader();
      reader.onload = function(event) {
        var contents, sheet, sheets;
        contents = event.target.result;
        sheets = XLS.read(contents, {
          type: "binary"
        });
        sheet = sheets.Sheets[sheets.SheetNames[0]];
        return console.log(sheet);
      };
      reader.onerror = function(event) {
        return console.error("Problems reading file, code:  " + event.target.error.code);
      };
      return reader.readAsBinaryString(newVal);
    });
    $scope.triggerImport = function() {
      return $('#file').trigger('click');
    };
    $scope.reRender = reRender;
    $scope.models = getModels();
    $scope.current = 0;
    $scope["new"] = function() {
      return $scope.models.push(copyObj(modelTemplate));
    };
    $scope.model = $scope.models[$scope.current];
    $scope.updateCurrentModel = function(index) {
      $scope.current = index;
      return $scope.model = $scope.models[$scope.current];
    };
    $scope.$watch('model', function() {
      return $scope.reRender($scope.stage, $scope.model);
    }, true);
    $scope.calcPrice = function(model) {
      if (model == null) {
        model = $scope.model;
      }
      return model.order * 20;
    };
    return $scope.summary = function(models) {
      var model, summary, _i, _len;
      if (models == null) {
        models = $scope.models;
      }
      summary = {};
      summary.price = 0;
      summary.order = 0;
      for (_i = 0, _len = models.length; _i < _len; _i++) {
        model = models[_i];
        summary.price += $scope.calcPrice(model);
        summary.order += model.order;
      }
      return summary;
    };
  });

}).call(this);

//# sourceMappingURL=signs.js.map
